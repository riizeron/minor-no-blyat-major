% m = 2;
% k = 20;
%
% Дано уравнение:
% u" + [2 + 20*cos(px)]*u = 0
%
% Перепишем его в виде системы первого порядка:
% { u1' = u2;
% { u2' = -[2 + 20*cos(px)]*u1
% И создадим файл функции
%
% Заметим, что от параметра p зависит только переодичность
% Поэтому определим p например равным двум:
p = 2;
% Зададим промежуток, на котором нужно найти решения:
tspan = [0 2*pi/p];
% Определим два начальных условия:
u01 = [1 0];
u02 = [0 1];
% Построим численно два решения на периоде 2pi/p
% (Ввиду недостатка точности функции ode45 для данной задачи,
% из-за чего я впал в недоумение когда произведение собственных чисел 
% отличалось от единицы более чем на 0.12, решено использовать более точную
% ode78).
% 
options = odeset('RelTol',1e-0,'AbsTol',1e-3,'MaxStep', 0.05);
% При первом начальном условии:
[t,u] = ode78(@(t,u)matie(t,u,p), tspan, u01, options);
%
figure(1);
hold on;
plot(t,u);
% При втором:
[t,u1] = ode78(@(t,u1)matie(t,u1,p), tspan, u02, options);
plot(t,u1);
hold off;
legend('u = [1 0]','u = [1 0]', 'u1 = [0 1]', 'u1 = [0 1]');
% Фазовая траектория на заданном периоде.
figure(2);
hold on;
plot(u(:,1),u(:,2));
hold off;
title('Фазовая траетория на периоде');
%
% Определим матрицы Вроньского на заданном периоде
% сразу найдем их вронскиан и запишем в массив.
w=zeros(0,length(u1));
for k=1:length(u1)
    w(k) = det([u(k,1), u1(k,1);
                u(k,2), u1(k,2)]);
end
% При t = 0 вронскиан равен определителю матрицы начальных условий,
% то есть единице.
% Построим график отклонения вронскиана:
figure(3);
hold on;
plot(t,w);
plot(t,1);
hold off;
legend('Отклонение вронскиана', 'Вронскиан');
title('График отклонения вронскиана (из-за погрешности он в конце промежутка не сошелся к единице)');
%
% Составим матрицу из полученных в конце периода решений.
% Это будет матрица монодромии.
M = [u(end,1), u1(end,1);
    u(end, 2), u1(end,2)];
% Найдем ее собственные числа (мультипликаторы):
D = eig(M);
display(D);
% А теперь их произведение:
display(D(1)*D(2));
det(M)
% Ура, оно теперь куда более похоже на единицу - 1.0059!!!
% Для сравнения, ode45 выдавал - 0.8717.
%
% Найдем на промежутке [0 10] такое p, что абсолютное значение
% обоих мультипликаторов равно единице.
% Для начала введем погрешность
eps = 0.000000001;
% И зададим p
p = linspace(0,10,101);
% Далее через цикл найдем подходящие знаения p и запишем их в массив
ps = zeros(length(p),1);
i=1;
for k=1:length(p)
    [t,u] = ode78(@(t,u)matie(t,u,p(k)),tspan,u01,options);
    [t,u1] = ode78(@(t,u)matie(t,u,p(k)),tspan,u02,options);
    M0 = [u(end,1), u1(end,1);
          u(end, 2), u1(end,2)];
    D0 = eig(M0);
    if((abs(D0(1))>=1-eps&&abs(D0(1))<=1+eps)&&((abs(D0(2)) >= 1-eps)&&abs(D0(2)) <= 1+eps))
        ps(i,1) = p(k);
        i=i+1;
    end
end
% Записали в массив ps те p, при которых система устойчива.
% В нашем случае мы получили области: [0,0.5], [7.6,9], 10
% Построим решение уравнения ну пусть в точке 8.
p=8;
% Подправим промежуток для наглядности устойчивости
tspan = [0 2*pi/p*16];
[t,u] = ode78(@(t,u)matie(t,u,p), tspan, u01, options);
figure(4);
plot(t,u);
% Заметим по графику, что динамическая система при данном p устойчива